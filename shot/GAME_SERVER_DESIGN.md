# 游戏服务器设计方案

## 一、服务器架构设计

### 1. 整体架构
- **分层设计**：采用分层架构，分为网络层、业务逻辑层和数据存储层
- **模块划分**：
  - 网络模块：处理WebSocket连接和HTTP请求
  - 业务模块：用户管理、房间管理、游戏逻辑
  - 数据模块：用户数据、房间数据、游戏结果存储
  - 安全模块：加密传输、身份验证

### 2. 核心组件
- **Hub**：核心消息处理中心，管理所有客户端连接
- **Client**：客户端连接的封装，处理消息的读写
- **Handler**：HTTP请求处理，包括用户和房间管理
- **Store**：数据存储，支持持久化到文件

### 3. 并发模型
- 采用Goroutine+Channel的并发模型
- 每个WebSocket连接对应两个Goroutine（读和写）
- Hub使用Channel进行消息传递，确保线程安全

## 二、协议设计

### 1. 协议格式
- **数据格式**：JSON格式序列化和反序列化
- **加密方式**：对称加密（AES-256）
- **消息结构**：
  ```json
  {
    "type": "消息类型",
    "payload": "消息内容（JSON字符串）"
  }
  ```

### 2. 消息类型

| 消息类型 | 描述 | 方向 |
|---------|------|------|
| register | 注册请求 | 客户端→服务器 |
| register_result | 注册结果 | 服务器→客户端 |
| login | 登录请求 | 客户端→服务器 |
| login_result | 登录结果 | 服务器→客户端 |
| logout | 登出请求 | 客户端→服务器 |
| heartbeat | 心跳请求 | 客户端→服务器 |
| heartbeat_reply | 心跳回复 | 服务器→客户端 |
| create_room | 创建房间请求 | 客户端→服务器 |
| room_list | 房间列表请求 | 客户端→服务器 |
| join_room | 加入房间请求 | 客户端→服务器 |
| join_room_result | 加入房间结果 | 服务器→客户端 |
| start_game | 开始游戏请求 | 客户端→服务器 |
| game_start | 游戏开始通知 | 服务器→客户端 |
| game_state | 游戏状态同步 | 服务器→客户端 |
| player_action | 玩家动作 | 客户端→服务器 |
| fire | 开火动作 | 客户端→服务器 |
| hit | 命中动作 | 客户端→服务器 |
| death | 死亡动作 | 客户端→服务器 |
| game_over | 游戏结束 | 服务器→客户端 |
| error | 错误信息 | 服务器→客户端 |

### 3. 核心消息定义

#### 3.1 房间管理消息

##### 创建房间请求
```json
{
  "type": "create_room",
  "payload": {
    "name": "房间名称",
    "max_players": 2
  }
}
```

##### 加入房间请求
```json
{
  "type": "join_room",
  "payload": {
    "room_id": "房间ID"
  }
}
```

##### 房间列表请求
```json
{
  "type": "room_list",
  "payload": {}
}
```

#### 3.2 游戏动作消息

##### 玩家动作消息
```json
{
  "type": "player_action",
  "payload": {
    "player_id": "玩家ID",
    "action": "move/stop",
    "value": 方向值,
    "x": 位置X,
    "y": 位置Y,
    "direction": 朝向
  }
}
```

##### 开火消息
```json
{
  "type": "fire",
  "payload": {
    "player_id": "玩家ID",
    "direction": 方向,
    "bullet_id": "子弹ID",
    "x": 发射位置X,
    "y": 发射位置Y
  }
}
```

##### 命中消息
```json
{
  "type": "hit",
  "payload": {
    "target_id": "目标玩家ID",
    "damage": 伤害值,
    "remaining": 剩余血量
  }
}
```

##### 游戏开始消息
```json
{
  "type": "game_start",
  "payload": {
    "room_id": "房间ID",
    "players": ["玩家1ID", "玩家2ID"],
    "hero1": {
      "id": "英雄1ID",
      "x": 初始位置X,
      "y": 初始位置Y,
      "hp": 初始血量,
      "direction": 初始朝向
    },
    "hero2": {
      "id": "英雄2ID",
      "x": 初始位置X,
      "y": 初始位置Y,
      "hp": 初始血量,
      "direction": 初始朝向
    }
  }
}
```

## 三、核心功能实现

### 1. 用户管理
- **注册**：检查用户名格式、唯一性，存储用户信息
- **登录**：验证用户名密码，标记用户在线状态
- **登出**：标记用户离线，清理房间信息
- **在线状态管理**：通过心跳检测维护用户在线状态

### 2. 房间管理
- **房间创建**：生成唯一房间ID，设置房主，初始化房间状态
- **房间列表**：返回所有可加入的房间（非游戏中）
- **房间加入**：检查房间状态，添加玩家到房间
- **房间状态管理**：等待中、准备中、游戏中、已结束

### 3. WebSocket消息处理

#### 3.1 消息处理流程
1. 客户端发送WebSocket消息到服务器
2. 服务器的`readPump`函数接收消息
3. 调用`handleMessage`函数处理消息
4. 根据消息类型执行相应的业务逻辑
5. 返回结果给客户端或广播给相关玩家

#### 3.2 消息类型处理

| 消息类型 | 处理逻辑 |
|---------|---------|
| `heartbeat` | 更新心跳时间戳，返回心跳回复 |
| `player_action` | 广播玩家动作给同一房间的其他玩家 |
| `fire` | 广播开火动作给同一房间的其他玩家 |
| `hit` | 广播命中动作给同一房间的其他玩家 |
| `death` | 处理玩家死亡，判定游戏结束 |
| `game_over` | 记录游戏结果，更新房间状态 |
| `start_game` | 验证房主权限，启动游戏，通知所有玩家 |
| `create_room` | 创建新房间，返回房间信息 |
| `room_list` | 返回所有可加入的房间列表 |
| `join_room` | 验证房间状态，添加玩家到房间 |

#### 3.3 关键实现代码

```go
func (h *Hub) handleMessage(client *Client, message []byte) {
    var msg protocol.Message
    if err := json.Unmarshal(message, &msg); err != nil {
        return
    }

    switch msg.Type {
    case protocol.MsgTypeHeartbeat:
        // 处理心跳请求
        
    case protocol.MsgTypeCreateRoom:
        // 处理创建房间请求
        
    case protocol.MsgTypeRoomList:
        // 处理获取房间列表请求
        
    case protocol.MsgTypeJoinRoom:
        // 处理加入房间请求
        
    // 其他消息类型处理...
    }
}
```

### 4. 游戏逻辑
- **游戏初始化**：设置两个hero的初始位置和状态
- **位置同步**：广播玩家位置变化
- **朝向同步**：广播玩家朝向变化
- **开火同步**：广播开火动作，生成子弹
- **碰撞检测**：处理子弹命中逻辑
- **血量同步**：更新并广播玩家血量变化
- **死亡处理**：处理玩家死亡，播放死亡动画，记录游戏结果
- **游戏结束**：广播游戏结果，更新房间状态

### 5. 心跳机制
- 客户端每2秒发送一次心跳请求
- 服务器维护心跳时间戳
- 超过10秒未收到心跳，标记用户离线

## 四、数据存储设计

### 1. 存储方式
- 采用JSON文件本地存储，便于开发和调试
- 支持扩展到数据库（如MySQL、MongoDB）

### 2. 存储结构
- **用户数据**：用户名、密码、邮箱、在线状态、房间ID
- **房间数据**：房间ID、名称、房主ID、玩家列表、最大玩家数、状态
- **游戏结果**：结果ID、房间ID、获胜者、失败者、游戏时间、持续时间

### 3. 数据一致性
- 使用互斥锁（sync.RWMutex）确保并发安全
- 写操作时自动保存到文件

## 五、安全性设计

### 1. 加密传输
- 采用AES-256对称加密算法
- 加密所有WebSocket传输的数据包
- 密钥管理：服务器和客户端共享密钥

### 2. 身份验证
- 用户名密码验证
- 在线状态验证
- 房间权限验证

## 六、服务器优化

### 1. 性能优化
- 减少锁竞争，使用读写锁分离读写操作
- 合理设置Channel缓冲区大小
- 优化广播机制，只向相关玩家发送消息

### 2. 可靠性优化
- 优雅处理客户端断开连接
- 定期清理过期房间和数据
- 支持服务器重启后数据恢复

### 3. 可扩展性
- 模块化设计，便于添加新功能
- 支持横向扩展，可部署多个服务器节点
- 支持多种游戏模式扩展

## 七、部署和运行

### 1. 环境要求
- Go 1.18+ 版本
- Windows 11 操作系统

### 2. 运行步骤
- 进入服务器目录：`cd d:\lwdd\code\tmp\socket\game\server`
- 安装依赖：`go mod tidy`
- 运行服务器：`go run main.go`
- 服务器将启动在 `http://localhost:8080`
- WebSocket地址：`ws://localhost:8080/ws?username=xxx`

### 3. 测试和监控
- 提供测试接口：`http://localhost:8080/user/test`
- 日志输出：记录服务器运行状态和错误信息
- 心跳检测：实时监控客户端连接状态

### 4. 常见问题及解决方案

#### 4.1 端口冲突
- **问题**：`listen tcp :8080: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.`
- **解决方案**：
  1. 查找占用8080端口的进程：`netstat -ano | findstr :8080`
  2. 终止占用端口的进程：`taskkill /PID <进程ID> /F`
  3. 重新启动服务器

#### 4.2 CORS跨域问题
- **问题**：`Access to fetch at 'http://localhost:8080/user/login' from origin 'http://localhost:5174' has been blocked by CORS policy`
- **解决方案**：
  1. 在服务器中添加CORS中间件
  2. 配置允许所有来源的请求：`Access-Control-Allow-Origin: *`
  3. 允许必要的HTTP方法和请求头
  4. 处理OPTIONS预检请求

#### 4.3 代码语法错误
- **问题**：编译错误，如多余的闭合大括号
- **解决方案**：检查代码语法，修复错误后重新编译运行

#### 4.4 WebSocket连接失败
- **问题**：客户端无法建立WebSocket连接
- **解决方案**：
  1. 检查服务器是否正在运行
  2. 验证WebSocket URL是否正确
  3. 检查防火墙设置，确保端口8080开放

## 八、客户端对接指南

### 1. 连接流程
1. 客户端注册/登录
2. 获取房间列表
3. 创建或加入房间
4. 等待游戏开始
5. 建立WebSocket连接
6. 发送心跳请求（每2秒）
7. 接收游戏开始通知
8. 同步游戏状态
9. 发送游戏动作
10. 接收游戏结果

### 2. 消息处理
- 所有消息必须经过加密处理
- 消息类型必须严格按照协议定义
- 客户端必须处理所有服务器发送的消息类型

### 3. 错误处理
- 处理WebSocket连接错误
- 处理消息解析错误
- 处理服务器返回的错误信息

## 九、总结

本设计方案基于现有的代码架构，实现了一个完整的游戏服务器，包括用户管理、房间管理、游戏逻辑、数据存储和安全机制。服务器采用Go语言开发，具有高性能、高可靠性和良好的可扩展性。

根据README.md中的要求，本设计方案实现了所有必需的功能，包括：
- 用户注册、登录、登出
- 房间系统
- WebSocket通信
- 心跳机制
- 游戏状态同步
- 位置、朝向、开火、命中、死亡等游戏动作处理
- 对称加密传输
- JSON格式协议

该设计方案可以作为游戏服务器的完整实现指南，便于开发人员理解和扩展。